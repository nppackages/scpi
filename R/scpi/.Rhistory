1, 1, rep(0,Jtot+KMI-red))  # SOC definition
} else if (w.constr[["p"]] == "L2" & w.constr[["dir"]] == "<=") { # ridge
aux <- unlist(lapply(1:I, function(x) c(1,1,rep(0,J[[x]]))))
h <- c(-d,                         # linear part of QF
Q1^2,                       # s <= Q1^2
aux,                        # SOC definition (||w|| <= s)
1, 1, rep(0,Jtot+KMI-red))  # SOC definition (||sqrt(Q)beta|| <= t)
} else if (w.constr[["p"]] == "L1-L2") { # L1-L2
aux <- unlist(lapply(1:I, function(x) c(1,1,rep(0,J[[x]]))))
h <- c(-d,                         # linear part of QF
-lb,                        # lower bounds of w
Q2^2,                       # s <= Q2^2
aux,                        # SOC definition (||w||_2 <= s)
1, 1, rep(0,Jtot+KMI-red))  # SOC definition (||sqrt(Q)beta|| <= t)
} else if (w.constr[["p"]] == "no norm") { # ols
h <- c(-d,                         # linear part of QF
1, 1, rep(0,Jtot+KMI-red))  # SOC definition
}
return(h)
}
load("/Users/fpalomba/Dropbox (Princeton)/projects/scpi/packages/fixed_bugs/wspace1.Rdata")
library(profvis)
library(ECOSolveR)
library(Matrix)
library(CVXR)
sqrtm <- function(A) {
decomp <- svd(A)
decomp$d[decomp$d < 0] <- 0
rootA  <- decomp$u %*% diag(sqrt(decomp$d)) %*% t(decomp$u)
return(rootA)
}
matRegularize <- function(mat, threshold = 1e-08) {
matsvd <- eigen(mat, symmetric = TRUE, only.values = FALSE)
sel <- matsvd$values > threshold
U <- matsvd$vectors[, sel]
D <- diag(sqrt(matsvd$values[sel]))
matreg <- D %*% t(U)
return(matreg)
}
blockdiag <- function(I, Jtot, J, KMI, ns, slack = FALSE) {
mat <- matrix(0, nrow = I, ncol = Jtot + KMI + ns)
j.lb <- 1
j.ub <- J[[1]]
if (slack == TRUE) {
j.lb <- j.lb + Jtot + KMI
j.ub <- j.ub + Jtot + KMI
}
for (i in seq_len(I)) {
if (i > 1){
j.lb <- j.ub + 1
j.ub <- j.lb + J[[i]] - 1
}
mat[i, j.lb:j.ub] <- 1
}
return(mat)
}
blockdiagRidge <- function(Jtot, J, KMI, I) {
mat <- matrix(0, Jtot + 2 * I, Jtot + KMI + I + 1)
i.lb <- 1 + 2
i.ub <- J[[1]] + 2
j.lb <- 1
j.ub <- J[[1]]
for (i in seq_len(I)) {
if (i > 1){
j.lb <- j.ub + 1
j.ub <- j.lb + J[[i]] - 1
i.lb <- i.ub + 1 + 2
i.ub <- i.lb + J[[i]] - 1
}
mat[(i.lb - 2):(i.lb - 1), Jtot+KMI+i] <- c(-1, 1)
mat[i.lb:i.ub, j.lb:j.ub] <- -diag(2, i.ub - i.lb + 1, j.ub - j.lb + 1)
}
return(mat)
}
ECOS_get_n_slacks <- function(w.constr, Jtot, I) {
n_slacks <- 1
# in lasso we add one slack per component of w to handle the abs value
if (w.constr[["p"]] == "L1" & w.constr[["dir"]] == "<=") { # lasso
n_slacks <- Jtot + n_slacks
}
# in ridge we have two hyperbolic constraints (norm and loss function)
if (w.constr[["p"]] == "L2" & w.constr[["dir"]] == "<=") { # ridge
n_slacks <- I + n_slacks
}
# L1-L2 combines ridge and simplex slack variables
if (w.constr[["p"]] == "L1-L2") { # L1-L2
n_slacks <- I + n_slacks
}
return(n_slacks)
}
ECOS_get_dims <- function(Jtot, J, KMI, w.constr, I, red) {
if (w.constr[["p"]] == "L1" & w.constr[["dir"]] == "==") { # simplex
dims <- list("l" = Jtot + 1, "q" = list(Jtot + KMI + 2 - red), "e" = 0)
} else if (w.constr[["p"]] == "L1" & w.constr[["dir"]] == "<=") { # lasso
dims <- list("l" = 1 + 2*Jtot + I, "q" = list(Jtot + KMI + 2 - red), "e" = 0)
} else if (w.constr[["p"]] == "L2" & w.constr[["dir"]] == "<=") { # ridge
dims <- list("l" = 1 + I, "q" = append(lapply(J, function(i) i+2), Jtot + KMI + 2 - red), "e" = 0)
} else if (w.constr[["p"]] == "L1-L2") { # L1-L2
dims <- list("l" = 1 + I + Jtot, "q" = append(lapply(J, function(i) i+2), Jtot + KMI + 2 - red), "e" = 0)
} else if (w.constr[["p"]] == "no norm") { # ols
dims <- list("l" = 1, "q" = list(Jtot + KMI + 2 - red), "e" = 0)
}
return(dims)
}
ECOS_get_c <- function(xt, ns) {
C <- c(xt, rep(0, ns))
return(C)
}
ECOS_get_A <- function(J, Jtot, KMI, I, w.constr, ns) {
if ((w.constr[["p"]] == "L1" & w.constr[["dir"]] == "==") || w.constr[["p"]] == "L1-L2") { # simplex, L1-L2
A <- blockdiag(I, Jtot, J, KMI, ns)
} else  { # ols, lasso, ridge
A <- matrix(NA, 0, 0)
}
return(methods::as(A, "sparseMatrix"))
}
ECOS_get_b <- function(Q1, Q2, w.constr) {
if ((w.constr[["p"]] == "L1" & w.constr[["dir"]] == "==") || w.constr[["p"]] == "L1-L2") { # simplex, L1-L2
b <- Q1
} else { # ols, lasso, ridge
b <- NULL
}
return(b)
}
ECOS_get_G <- function(Jtot, KMI, J, I, a, Q, w.constr, ns, red) {
if (w.constr[["p"]] == "L1" & w.constr[["dir"]] == "==") { # simplex
G <- rbind(c(a, 1),                                                                  # linear part of QF
cbind(-diag(1,Jtot), matrix(0, Jtot, KMI), matrix(0, Jtot, ns)),          # lower bounds on w
c(rep(0, Jtot+KMI),-1),                                                   # SOC definition (||sqrt(Q)beta|| <= t)
c(rep(0, Jtot+KMI), 1),
cbind(-2*Q, rep(0, Jtot+KMI-red)))
} else if (w.constr[["p"]] == "L1" & w.constr[["dir"]] == "<=") { # lasso, x = (beta, z, t)
G <- rbind(c(a, rep(0, ns-1), 1),                                                    # linear part of QF
cbind(diag(1, Jtot), matrix(0, Jtot, KMI), diag(1, Jtot), rep(0, Jtot)),  # z >= -w
cbind(-diag(1, Jtot), matrix(0, Jtot, KMI), diag(1, Jtot), rep(0, Jtot)), # z >= w
-blockdiag(I, Jtot, J, KMI, ns, TRUE),                                    # norm-inequality constraint
c(rep(0, Jtot+KMI+Jtot),-1),                                              # SOC definition (||sqrt(Q)beta|| <= t)
c(rep(0, Jtot+KMI+Jtot), 1),
cbind(-2*Q, matrix(0, Jtot+KMI-red, Jtot + 1)))
} else if (w.constr[["p"]] == "L2" & w.constr[["dir"]] == "<=") { # ridge, x = (beta, s, t)
G <- rbind(c(a, rep(0, I), 1),                                                       # linear part of QF
cbind(matrix(0, I, Jtot+KMI), diag(1, I, I), rep(0, I)),                  # s <= Q1^2
blockdiagRidge(Jtot, J, KMI, I),                                          # SOC definition (||w|| <= s)
c(rep(0, Jtot+KMI), rep(0, I), -1),                                       # SOC definition (||sqrt(Q)beta|| <= t)
c(rep(0, Jtot+KMI), rep(0, I), 1),
cbind(-2*Q, matrix(0, Jtot+KMI-red, I + 1)))
} else if (w.constr[["p"]] == "L1-L2") { # L1-L2, x = (beta, s, t)
G <- rbind(c(a, rep(0, ns-1), 1),                                                    # linear part of QF
cbind(-diag(1,Jtot), matrix(0, Jtot, KMI), matrix(0, Jtot, ns)),          # lower bounds on w
cbind(matrix(0, I, Jtot+KMI), diag(1, I, I), rep(0, I)),                  # s <= Q2^2
blockdiagRidge(Jtot, J, KMI, I),                                          # SOC definition (||w||_2 <= s)
c(rep(0, Jtot+KMI), rep(0, I), -1),                                       # SOC definition (||sqrt(Q)beta||_2 <= t)
c(rep(0, Jtot+KMI), rep(0, I), 1),
cbind(-2*Q, matrix(0, Jtot+KMI-red, I + 1)))
} else if (w.constr[["p"]] == "no norm") { # ols
G <- rbind(c(a, 1),                                                                  # linear part of QF
c(rep(0, Jtot+KMI),-1),                                                   # SOC definition (||sqrt(Q)beta|| <= t)
c(rep(0, Jtot+KMI), 1),
cbind(-2*Q, rep(0, Jtot+KMI-red)))
}
return(methods::as(G, "sparseMatrix"))
}
ECOS_get_h <- function(d, lb, J, Jtot, KMI, I, w.constr, Q1, Q2, red) {
if (w.constr[["p"]] == "L1" & w.constr[["dir"]] == "==") { # simplex
h <- c(-d,                         # linear part of QF
-lb,                        # lower bounds of w
1, 1, rep(0,Jtot+KMI-red))  # SOC definition
} else if (w.constr[["p"]] == "L1" & w.constr[["dir"]] == "<=") { # lasso
h <- c(-d,                         # linear part of QF
rep(0, 2*Jtot),             # abs(w) <= z
Q1,                         # norm-inequality constraints
1, 1, rep(0,Jtot+KMI-red))  # SOC definition
} else if (w.constr[["p"]] == "L2" & w.constr[["dir"]] == "<=") { # ridge
aux <- unlist(lapply(1:I, function(x) c(1,1,rep(0,J[[x]]))))
h <- c(-d,                         # linear part of QF
Q1^2,                       # s <= Q1^2
aux,                        # SOC definition (||w|| <= s)
1, 1, rep(0,Jtot+KMI-red))  # SOC definition (||sqrt(Q)beta|| <= t)
} else if (w.constr[["p"]] == "L1-L2") { # L1-L2
aux <- unlist(lapply(1:I, function(x) c(1,1,rep(0,J[[x]]))))
h <- c(-d,                         # linear part of QF
-lb,                        # lower bounds of w
Q2^2,                       # s <= Q2^2
aux,                        # SOC definition (||w||_2 <= s)
1, 1, rep(0,Jtot+KMI-red))  # SOC definition (||sqrt(Q)beta|| <= t)
} else if (w.constr[["p"]] == "no norm") { # ols
h <- c(-d,                         # linear part of QF
1, 1, rep(0,Jtot+KMI-red))  # SOC definition
}
return(h)
}
load("/Users/fpalomba/Dropbox (Princeton)/projects/scpi/packages/fixed_bugs/wspace.Rdata")
vsig <- matrix(NA, nrow = 200, ncol = 2 * nrow(P.na))
w.constr.inf[["p"]] <- "L1"
w.constr.inf[["dir"]] <- "=="
w.constr.inf[["lb"]] <- 0
Q2.star <- rep(1,2)
p <- w.constr.inf$p
dire <- w.constr.inf$dir
lb <- rep(w.constr.inf$lb, sum(unlist(J)))
# simulate
ns <- ECOS_get_n_slacks(w.constr.inf, Jtot, I)
Qreg <- matRegularize(Q)
dimred <- nrow(Q) - nrow(Qreg)
if (dimred==0) {
Qreg <- sqrtm(Q)
}
data <- list()
data[["dims"]] <- ECOS_get_dims(Jtot, J, KMI, w.constr.inf, I, dimred)
data[["A"]] <- ECOS_get_A(J, Jtot, KMI, I, w.constr.inf, ns)
library(profvis)
library(ECOSolveR)
library(Matrix)
library(CVXR)
sqrtm <- function(A) {
decomp <- svd(A)
decomp$d[decomp$d < 0] <- 0
rootA  <- decomp$u %*% diag(sqrt(decomp$d)) %*% t(decomp$u)
return(rootA)
}
matRegularize <- function(mat, threshold = 1e-08) {
matsvd <- eigen(mat, symmetric = TRUE, only.values = FALSE)
sel <- matsvd$values > threshold
U <- matsvd$vectors[, sel]
D <- diag(sqrt(matsvd$values[sel]))
matreg <- D %*% t(U)
return(matreg)
}
blockdiag <- function(I, Jtot, J, KMI, ns, slack = FALSE) {
mat <- matrix(0, nrow = I, ncol = Jtot + KMI + ns)
j.lb <- 1
j.ub <- J[[1]]
if (slack == TRUE) {
j.lb <- j.lb + Jtot + KMI
j.ub <- j.ub + Jtot + KMI
}
for (i in seq_len(I)) {
if (i > 1){
j.lb <- j.ub + 1
j.ub <- j.lb + J[[i]] - 1
}
mat[i, j.lb:j.ub] <- 1
}
return(mat)
}
blockdiagRidge <- function(Jtot, J, KMI, I) {
mat <- matrix(0, Jtot + 2 * I, Jtot + KMI + I + 1)
i.lb <- 1 + 2
i.ub <- J[[1]] + 2
j.lb <- 1
j.ub <- J[[1]]
for (i in seq_len(I)) {
if (i > 1){
j.lb <- j.ub + 1
j.ub <- j.lb + J[[i]] - 1
i.lb <- i.ub + 1 + 2
i.ub <- i.lb + J[[i]] - 1
}
mat[(i.lb - 2):(i.lb - 1), Jtot+KMI+i] <- c(-1, 1)
mat[i.lb:i.ub, j.lb:j.ub] <- -diag(2, i.ub - i.lb + 1, j.ub - j.lb + 1)
}
return(mat)
}
ECOS_get_n_slacks <- function(w.constr, Jtot, I) {
n_slacks <- 1
# in lasso we add one slack per component of w to handle the abs value
if (w.constr[["p"]] == "L1" & w.constr[["dir"]] == "<=") { # lasso
n_slacks <- Jtot + n_slacks
}
# in ridge we have two hyperbolic constraints (norm and loss function)
if (w.constr[["p"]] == "L2" & w.constr[["dir"]] == "<=") { # ridge
n_slacks <- I + n_slacks
}
# L1-L2 combines ridge and simplex slack variables
if (w.constr[["p"]] == "L1-L2") { # L1-L2
n_slacks <- I + n_slacks
}
return(n_slacks)
}
ECOS_get_dims <- function(Jtot, J, KMI, w.constr, I, red) {
if (w.constr[["p"]] == "L1" & w.constr[["dir"]] == "==") { # simplex
dims <- list("l" = Jtot + 1, "q" = list(Jtot + KMI + 2 - red), "e" = 0)
} else if (w.constr[["p"]] == "L1" & w.constr[["dir"]] == "<=") { # lasso
dims <- list("l" = 1 + 2*Jtot + I, "q" = list(Jtot + KMI + 2 - red), "e" = 0)
} else if (w.constr[["p"]] == "L2" & w.constr[["dir"]] == "<=") { # ridge
dims <- list("l" = 1 + I, "q" = append(lapply(J, function(i) i+2), Jtot + KMI + 2 - red), "e" = 0)
} else if (w.constr[["p"]] == "L1-L2") { # L1-L2
dims <- list("l" = 1 + I + Jtot, "q" = append(lapply(J, function(i) i+2), Jtot + KMI + 2 - red), "e" = 0)
} else if (w.constr[["p"]] == "no norm") { # ols
dims <- list("l" = 1, "q" = list(Jtot + KMI + 2 - red), "e" = 0)
}
return(dims)
}
ECOS_get_c <- function(xt, ns) {
C <- c(xt, rep(0, ns))
return(C)
}
ECOS_get_A <- function(J, Jtot, KMI, I, w.constr, ns) {
if ((w.constr[["p"]] == "L1" & w.constr[["dir"]] == "==") || w.constr[["p"]] == "L1-L2") { # simplex, L1-L2
A <- blockdiag(I, Jtot, J, KMI, ns)
} else  { # ols, lasso, ridge
A <- matrix(NA, 0, 0)
}
return(methods::as(A, "sparseMatrix"))
}
ECOS_get_b <- function(Q1, Q2, w.constr) {
if ((w.constr[["p"]] == "L1" & w.constr[["dir"]] == "==") || w.constr[["p"]] == "L1-L2") { # simplex, L1-L2
b <- Q1
} else { # ols, lasso, ridge
b <- NULL
}
return(b)
}
ECOS_get_G <- function(Jtot, KMI, J, I, a, Q, w.constr, ns, red) {
if (w.constr[["p"]] == "L1" & w.constr[["dir"]] == "==") { # simplex
G <- rbind(c(a, 1),                                                                  # linear part of QF
cbind(-diag(1,Jtot), matrix(0, Jtot, KMI), matrix(0, Jtot, ns)),          # lower bounds on w
c(rep(0, Jtot+KMI),-1),                                                   # SOC definition (||sqrt(Q)beta|| <= t)
c(rep(0, Jtot+KMI), 1),
cbind(-2*Q, rep(0, Jtot+KMI-red)))
} else if (w.constr[["p"]] == "L1" & w.constr[["dir"]] == "<=") { # lasso, x = (beta, z, t)
G <- rbind(c(a, rep(0, ns-1), 1),                                                    # linear part of QF
cbind(diag(1, Jtot), matrix(0, Jtot, KMI), diag(1, Jtot), rep(0, Jtot)),  # z >= -w
cbind(-diag(1, Jtot), matrix(0, Jtot, KMI), diag(1, Jtot), rep(0, Jtot)), # z >= w
-blockdiag(I, Jtot, J, KMI, ns, TRUE),                                    # norm-inequality constraint
c(rep(0, Jtot+KMI+Jtot),-1),                                              # SOC definition (||sqrt(Q)beta|| <= t)
c(rep(0, Jtot+KMI+Jtot), 1),
cbind(-2*Q, matrix(0, Jtot+KMI-red, Jtot + 1)))
} else if (w.constr[["p"]] == "L2" & w.constr[["dir"]] == "<=") { # ridge, x = (beta, s, t)
G <- rbind(c(a, rep(0, I), 1),                                                       # linear part of QF
cbind(matrix(0, I, Jtot+KMI), diag(1, I, I), rep(0, I)),                  # s <= Q1^2
blockdiagRidge(Jtot, J, KMI, I),                                          # SOC definition (||w|| <= s)
c(rep(0, Jtot+KMI), rep(0, I), -1),                                       # SOC definition (||sqrt(Q)beta|| <= t)
c(rep(0, Jtot+KMI), rep(0, I), 1),
cbind(-2*Q, matrix(0, Jtot+KMI-red, I + 1)))
} else if (w.constr[["p"]] == "L1-L2") { # L1-L2, x = (beta, s, t)
G <- rbind(c(a, rep(0, ns-1), 1),                                                    # linear part of QF
cbind(-diag(1,Jtot), matrix(0, Jtot, KMI), matrix(0, Jtot, ns)),          # lower bounds on w
cbind(matrix(0, I, Jtot+KMI), diag(1, I, I), rep(0, I)),                  # s <= Q2^2
blockdiagRidge(Jtot, J, KMI, I),                                          # SOC definition (||w||_2 <= s)
c(rep(0, Jtot+KMI), rep(0, I), -1),                                       # SOC definition (||sqrt(Q)beta||_2 <= t)
c(rep(0, Jtot+KMI), rep(0, I), 1),
cbind(-2*Q, matrix(0, Jtot+KMI-red, I + 1)))
} else if (w.constr[["p"]] == "no norm") { # ols
G <- rbind(c(a, 1),                                                                  # linear part of QF
c(rep(0, Jtot+KMI),-1),                                                   # SOC definition (||sqrt(Q)beta|| <= t)
c(rep(0, Jtot+KMI), 1),
cbind(-2*Q, rep(0, Jtot+KMI-red)))
}
return(methods::as(G, "sparseMatrix"))
}
ECOS_get_h <- function(d, lb, J, Jtot, KMI, I, w.constr, Q1, Q2, red) {
if (w.constr[["p"]] == "L1" & w.constr[["dir"]] == "==") { # simplex
h <- c(-d,                         # linear part of QF
-lb,                        # lower bounds of w
1, 1, rep(0,Jtot+KMI-red))  # SOC definition
} else if (w.constr[["p"]] == "L1" & w.constr[["dir"]] == "<=") { # lasso
h <- c(-d,                         # linear part of QF
rep(0, 2*Jtot),             # abs(w) <= z
Q1,                         # norm-inequality constraints
1, 1, rep(0,Jtot+KMI-red))  # SOC definition
} else if (w.constr[["p"]] == "L2" & w.constr[["dir"]] == "<=") { # ridge
aux <- unlist(lapply(1:I, function(x) c(1,1,rep(0,J[[x]]))))
h <- c(-d,                         # linear part of QF
Q1^2,                       # s <= Q1^2
aux,                        # SOC definition (||w|| <= s)
1, 1, rep(0,Jtot+KMI-red))  # SOC definition (||sqrt(Q)beta|| <= t)
} else if (w.constr[["p"]] == "L1-L2") { # L1-L2
aux <- unlist(lapply(1:I, function(x) c(1,1,rep(0,J[[x]]))))
h <- c(-d,                         # linear part of QF
-lb,                        # lower bounds of w
Q2^2,                       # s <= Q2^2
aux,                        # SOC definition (||w||_2 <= s)
1, 1, rep(0,Jtot+KMI-red))  # SOC definition (||sqrt(Q)beta|| <= t)
} else if (w.constr[["p"]] == "no norm") { # ols
h <- c(-d,                         # linear part of QF
1, 1, rep(0,Jtot+KMI-red))  # SOC definition
}
return(h)
}
load("/Users/fpalomba/Dropbox (Princeton)/projects/scpi/packages/fixed_bugs/dataPinotti.Rdata")
vsig <- matrix(NA, nrow = 200, ncol = 2 * nrow(P.na))
w.constr.inf[["p"]] <- "L1"
w.constr.inf[["dir"]] <- "=="
w.constr.inf[["lb"]] <- 0
Q2.star <- rep(1,2)
p <- w.constr.inf$p
dire <- w.constr.inf$dir
lb <- rep(w.constr.inf$lb, sum(unlist(J)))
# simulate
ns <- ECOS_get_n_slacks(w.constr.inf, Jtot, I)
Qreg <- matRegularize(Q)
dimred <- nrow(Q) - nrow(Qreg)
if (dimred==0) {
Qreg <- sqrtm(Q)
}
data <- list()
data[["dims"]] <- ECOS_get_dims(Jtot, J, KMI, w.constr.inf, I, dimred)
data[["A"]] <- ECOS_get_A(J, Jtot, KMI, I, w.constr.inf, ns)
data[["b"]] <- ECOS_get_b(Q.star, Q2.star, w.constr.inf)
for (sim in seq_len(1)) {
set.seed(8894)
zeta    <- rnorm(length(beta))
G       <- Sigma.root %*% zeta
a <- -2 * G - 2 * c(t(beta) %*% Q)
d <- 2 * sum(G * beta) + sum(beta * (Q %*% beta))
data[["G"]] <- ECOS_get_G(Jtot, KMI, J, I, a, Qreg, w.constr.inf, ns, dimred)
data[["h"]] <- ECOS_get_h(d, lb, J, Jtot, KMI, I, w.constr.inf, Q.star, Q2.star, dimred)
for (hor in seq_len(1)) {
xt <- P.na[1, ]
data[["c"]] <- ECOS_get_c(-xt, ns)
solver_output <- ECOSolveR::ECOS_csolve(c = data[["c"]],
G = data[["G"]],
h = data[["h"]],
dims = data[["dims"]],
A = data[["A"]],
b = data[["b"]])
xx <- solver_output$x
print(-sum(xt*(xx[1:(Jtot+KMI)] - beta)))
#data[["c"]] <- ECOS_get_c(xt, w.constr.inf, ns)
x <- CVXR::Variable(Jtot+KMI)
constraints <- list(CVXR::quad_form(x, Q) + sum(CVXR::multiply(a, x)) + d <= 0)
if (lb[1] > - Inf) {
constraints <- append(constraints, list(x[1:Jtot] >= lb))
}
j.lb <- 1
for (i in seq_len(I)) {
j.ub <- j.lb + J[[i]] - 1
if (p == "L1") {
if (dire == "==") { # simplex
constraints <- append(constraints, list(CVXR::sum_entries(x[j.lb:j.ub]) == Q.star[i]))
} else if (dire == "<=") { # lasso
constraints <- append(constraints, list(CVXR::norm1(x[j.lb:j.ub]) <= Q.star[i]))
}
} else if (p == "L2") {  # ridge
constraints <- append(constraints, list(CVXR::sum_squares(x[j.lb:j.ub]) <= CVXR::power(Q.star[i], 2)))
} else if (p == "L1-L2") {
constraints <- append(constraints, list(CVXR::sum_entries(x[j.lb:j.ub]) == Q.star[i],
CVXR::sum_squares(x[j.lb:j.ub]) <= CVXR::power(Q2.star[i], 2)))
}
j.lb <- j.ub + 1
}
objective   <- CVXR::Minimize(-sum(CVXR::multiply(xt,x - beta)))
prob     <- CVXR::Problem(objective, constraints)
sol      <- CVXR::solve(prob)
print(sol$value)
prob_data <- CVXR::get_problem_data(prob, solver = "ECOS")
solver_output <- ECOSolveR::ECOS_csolve(c = prob_data$data[["c"]],
G = prob_data$data[["G"]],
h = prob_data$data[["h"]],
dims = CVXR::ECOS.dims_to_solver_dict(prob_data$data[["dims"]]),
A = prob_data$data[["A"]],
b = prob_data$data[["b"]],
control = ecos.control(maxit=1000L))
xx <- solver_output$x
print(-sum(xt*(xx[1:(Jtot+KMI)] - beta)))
}
}
solver_output
CVXR::get_problem_data
showMethods(get_problem_data)
(0.6-0.5)/sqrt(0.6*0.4/100)
(0.6-0.5)/sqrt(0.6*0.4)
(0.6-0.5)/(0.6*0.4/100)
(0.6-0.5)/sqrt(0.5*0.5/100)
b0 <- 8.240817
b1 <- -0.2245192*50
b2 <- -0.3426692*12
b0 <- 1.157882
b1 <- -0.0068817*50
b2 <- -0.0639984*12
print(sum(b0+b1+b2))
b0 <- 8.240817
b1 <- -0.2245192*50
b2 <- -0.3426692*12
print(sum(b0+b1+b2))
y <- sum(b0+b1+b2)
b0 <- 8.240817
b1 <- -0.2245192*50
b2 <- -0.3426692*12
y <- sum(b0+b1+b2)
print(y)
print(e^y/(1+e^(y)))
print(exp(y)/(1+exp(y)))
print(1/(1-exp(-y)))
print(1/(1+exp(-y)))
??scpi::scdataMulti
x=0.0456
e^x/(1+e^x)
exp(x)/(1+exp(x))
exp(1)
1/(1-exp(-x))
1/(1-exp(x))
1/(1+exp(-x))
(1+(15.10^2)/198)^(-1)
(1+((-4.50)^2)/72)^(-1)
1-(1+((-4.50)^2)/72)^(-1)
1-(1+(15.10^2)/198)^(-1)
sqrt(2*log(2/0.001))
remove.packages("scpi")
pacman::p_load(devtools, testthat)
#########################################################################################
## Change Version Below!!!
setwd("/Users/fpalomba/Dropbox (Princeton)/projects/scpi/packages/R/scpi")
# Prepare build ignore
usethis::use_build_ignore(c("tests",".gitignore"))
#usethis::use_github_action_check_standard()
# Prepare documentation
devtools::document()
# Install and check
devtools::build()
devtools::install(upgrade = "never")
