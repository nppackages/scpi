#######################################
set.seed(8894)
X.ls <- list()
for (i in 1:rep) {
X.ls[[i]] <- dgp.x(T0, ar)
}
# pick a realization in the medium range
range.l <- rowQuantiles(sapply(X.ls, function(x) colQuantiles(x, probs = 0.1)), probs=.2)
range.r <- rowQuantiles(sapply(X.ls, function(x) colQuantiles(x, probs = 0.9)), probs=.8)
within <- sapply(X.ls, function(x) check(x, range.l, range.r))
select <- which(within==T)[1]
data.x <- X.ls[[select]]
y.co.0 <- data.x[1:T0,]
y.co.1 <- data.x[(T0+1),,drop=F]
install.packages("matrixStats")
library(matrixStats)
range.l <- rowQuantiles(sapply(X.ls, function(x) colQuantiles(x, probs = 0.1)), probs=.2)
range.r <- rowQuantiles(sapply(X.ls, function(x) colQuantiles(x, probs = 0.9)), probs=.8)
within <- sapply(X.ls, function(x) check(x, range.l, range.r))
select <- which(within==T)[1]
data.x <- X.ls[[select]]
y.co.0 <- data.x[1:T0,]
y.co.1 <- data.x[(T0+1),,drop=F]
# Check if within a range
check <- function(x, l, r) {
return(all((colQuantiles(x, probs=0.1) > l) &
(colQuantiles(x, probs=0.9) < r)))
}
range.l <- rowQuantiles(sapply(X.ls, function(x) colQuantiles(x, probs = 0.1)), probs=.2)
range.r <- rowQuantiles(sapply(X.ls, function(x) colQuantiles(x, probs = 0.9)), probs=.8)
within <- sapply(X.ls, function(x) check(x, range.l, range.r))
select <- which(within==T)[1]
data.x <- X.ls[[select]]
y.co.0 <- data.x[1:T0,]
y.co.1 <- data.x[(T0+1),,drop=F]
library(tsDyn)
library(matrixStats)
library(ggplot2)
library(optiSolve)
library(Qtools)
library(latex2exp)
library(Hmisc)
library(abind)
library(Matrix)
library(magic)
library(nloptr)
library(magic)
library(dplyr)
library(tidyr)
library(doSNOW)
library(doRNG)
library(parallel)
library(CVXR)
source("D:\\Dropbox (Personal)\\Research\\Cattaneo\\packages\\cluster_sims\\funs.R")
setwd("D:\\Dropbox\\Research\\Cattaneo\\packages\\R\\scpi\\R")
source("supporting_functions.R")
source("scest.R")
source("scpi.R")
source("scdata.R")
source("scplot.R")
source("scest_methods.R")
source("scpi_methods.R")
## Simulation Parameters
rep   <- 20      # replications
T0    <- 100     # pre-treatment period
M     <- 400     # number of simulations
J     <- c(5,10,20,30,50,100) # donors pool size
J <- 5
w0.u  <- c(0.3, 0.4, 0.3, rep(0, J-3))  # true weights
ar  <- diag(J)*0.5  # matrix of coefficients of donors pool
#######################################
### Prepare design ####################
#######################################
set.seed(8894)
X.ls <- list()
for (i in 1:rep) {
X.ls[[i]] <- dgp.x(T0, ar)
}
# pick a realization in the medium range
range.l <- rowQuantiles(sapply(X.ls, function(x) colQuantiles(x, probs = 0.1)), probs=.2)
range.r <- rowQuantiles(sapply(X.ls, function(x) colQuantiles(x, probs = 0.9)), probs=.8)
within <- sapply(X.ls, function(x) check(x, range.l, range.r))
select <- which(within==T)[1]
data.x <- X.ls[[select]]
y.co.0 <- data.x[1:T0,]
y.co.1 <- data.x[(T0+1),,drop=F]
data <- dgp.cond(y.co.0, y.co.1, T0, J, model, w0.u)
rownames(data$y.co.0) <- paste0("outcome.", as.character(c(1:T0)))
rownames(data$y.tr.0) <- paste0("outcome.", as.character(c(1:T0)))
rownames(data$y.co.1) <- paste0("outcome.", as.character(T0+1))
rownames(data$y.tr.1) <- paste0("outcome.", as.character(T0+1))
colnames(data$y.co.0) <- paste0("donor.", as.character(c(1:J)))
colnames(data$y.tr.0) <- paste0("treated")
colnames(data$y.co.1) <- paste0("donor.", as.character(c(1:J)))
colnames(data$y.tr.1) <- paste0("treated")
specs <- list(J = J,
K = 0,
KM = 0,
M = 1,
cointegrated.data = F,
period.pre = c(1:T0),
period.post = c(T0+1),
T0.features = c(T0),
T1.outcome = 1,
features = c("feature1"),
glob.cons = F,
out.in.features = T)
df <- list(A = data$y.tr.0, B = data$y.co.0, C = NULL, P = data$y.co.1,
Y.pre = data$y.tr.0, Y.post = data$y.tr.1, Y.donors = data$y.co.0,
specs = specs)
class(df) <- 'scpi_data'
res <- scest(df)
print(res)
res <- scpi(df, w.constr = list(name="simplex",Q=1), cores = 1, sims = 100)
print(res)
x$inference.results$CI.all.gaussian
x$inference.results$CI.all.gaussian[, 1:2]
x$inference.results$CI.all.gaussian[, 1:2, drop = F]
setwd("D:\\Dropbox\\Research\\Cattaneo\\packages\\R\\scpi\\R")
source("supporting_functions.R")
source("scest.R")
source("scpi.R")
source("scdata.R")
source("scplot.R")
source("scest_methods.R")
source("scpi_methods.R")
res <- scpi(df, w.constr = list(name="simplex",Q=1), cores = 1, sims = 100)
print(res)
scplot(res)
scplot(scest(df))
setwd("D:\\Dropbox\\Research\\Cattaneo\\packages\\R\\scpi\\R")
source("supporting_functions.R")
source("scest.R")
source("scpi.R")
source("scdata.R")
source("scplot.R")
source("scest_methods.R")
source("scpi_methods.R")
res <- scpi(df, w.constr = list(name="simplex",Q=1), cores = 1, sims = 100)
print(res)
scplot(re
s)
scplot(res)
y.fit
Y.fit.na
not.missing.plot
Y.fit.na[not.missing.plot, 1]
rownames(y.fit)
aux<-scest(df)
aux$est.results$Y.post.fit
data$y.tr.1
data <- read.csv("Germany.csv")
#data <- Germany
## Set parameters for data preparation
id.var      <- "country"                             # ID variable
time.var    <- "year"                                # Time variable
period.pre  <- seq(from = 1960, to = 1990, by = 1)   # Pre-treatment period
period.post <- (1991:1997)                           # Post-treatment period
unit.tr     <- "West Germany"                        # Treated unit (in terms of id.var)
unit.co     <- unique(data$country)[-7]              # Donors pool
outcome.var <- "gdp"                                 # Outcome variable
cov.adj     <- NULL                                  # Covariates for adjustment
features    <- NULL                                  # No features other than outcome
constant    <- T                                     # No constant term
report.missing <- F                                  # To check where missing values are
cointegrated.data <- T                               # Belief that the data are cointegrated
cov.adj <- features <- NULL
#data <- data[!(data$country == "Austria" & data$year == 1992),]
## Data preparation
df  <-   scdata(df = data, id.var = id.var, time.var = time.var, outcome.var = outcome.var,
period.pre = period.pre, period.post = period.post,
unit.tr = unit.tr, unit.co = unit.co, cov.adj = cov.adj, features = features,
constant = constant,  report.missing = T, cointegrated.data = cointegrated.data)
## Estimate Synthetic Control with a simplex-type constraint (default) and plot results
set.seed(8894)
res.est <- scest(data = df, plot = F, plot.name = "germany_est",  w.constr = list(name = "ridge", Q = 1))
setwd("D:\\Dropbox\\Research\\Cattaneo\\packages_old\\R\\v0.6\\data")
data <- read.csv("Germany.csv")
#data <- Germany
## Set parameters for data preparation
id.var      <- "country"                             # ID variable
time.var    <- "year"                                # Time variable
period.pre  <- seq(from = 1960, to = 1990, by = 1)   # Pre-treatment period
period.post <- (1991:1997)                           # Post-treatment period
unit.tr     <- "West Germany"                        # Treated unit (in terms of id.var)
unit.co     <- unique(data$country)[-7]              # Donors pool
outcome.var <- "gdp"                                 # Outcome variable
cov.adj     <- NULL                                  # Covariates for adjustment
features    <- NULL                                  # No features other than outcome
constant    <- T                                     # No constant term
report.missing <- F                                  # To check where missing values are
cointegrated.data <- T                               # Belief that the data are cointegrated
cov.adj <- features <- NULL
#data <- data[!(data$country == "Austria" & data$year == 1992),]
## Data preparation
df  <-   scdata(df = data, id.var = id.var, time.var = time.var, outcome.var = outcome.var,
period.pre = period.pre, period.post = period.post,
unit.tr = unit.tr, unit.co = unit.co, cov.adj = cov.adj, features = features,
constant = constant,  report.missing = T, cointegrated.data = cointegrated.data)
## Estimate Synthetic Control with a simplex-type constraint (default) and plot results
set.seed(8894)
res.est <- scest(data = df, plot = F, plot.name = "germany_est",  w.constr = list(name = "ridge", Q = 1))
scplot(res.est)
res.pi  <- scpi(data = df, sims = 30, e.method = e.method, w.constr = list(name = "simplex", Q = 1),
u.order = 1, u.lags = 0, u.sigma = u.sigma, u.missp = u.missp,
cores = 3, e.lags = 0, e.order = 1)
print(res.pi)
rho      <- NULL                         # Regularization parameter (if NULL it is estimated)
rho.max  <- 1                            # Maximum value attainable by rho
sims     <- 100                          # Number of simulations
V        <- NULL                         # Weighting matrix
u.order  <- 1                            # Degree of polynomial in B and C when modelling u
u.lags   <- 0                            # Lags of B to be used when modelling u
u.sigma  <- "HC1"                        # Estimator for the variance-covariance of u
u.missp  <- T                            # If TRUE then the model is misspecified
e.lags   <- 0                            # Degree of polynomial in B and C when modelling e
e.order  <- 1                            # Lags of B to be used when modelling e
e.method <- "all"                        # Estimation method for out-of-sample uncertainty
cores    <- 1                            # Number of cores to be used by scpi
w.constr <- NULL
V = P = e.design = u.design = w.bounds = e.bounds = NULL
data =df
start.time <- Sys.time()
set.seed(8894)
set.seed(8894)
res.pi  <- scpi(data = df, sims = 30, e.method = e.method, w.constr = list(name = "simplex", Q = 1),
u.order = 1, u.lags = 0, u.sigma = u.sigma, u.missp = u.missp,
cores = 1, e.lags = 0, e.order = 1)
scplot(res.pi)
rownames(sc.l.0)
c(period.pre,period.post)
rownames(y.fit)
setwd("D:\\Dropbox\\Research\\Cattaneo\\packages\\R\\scpi\\R")
source("supporting_functions.R")
source("scest.R")
source("scpi.R")
source("scdata.R")
source("scplot.R")
source("scest_methods.R")
source("scpi_methods.R")
rep   <- 20      # replications
T0    <- 100     # pre-treatment period
M     <- 400     # number of simulations
J     <- c(5,10,20,30,50,100) # donors pool size
J <- 5
w0.u  <- c(0.3, 0.4, 0.3, rep(0, J-3))  # true weights
ar  <- diag(J)*0.5  # matrix of coefficients of donors pool
#######################################
### Prepare design ####################
#######################################
set.seed(8894)
X.ls <- list()
for (i in 1:rep) {
X.ls[[i]] <- dgp.x(T0, ar)
}
# pick a realization in the medium range
range.l <- rowQuantiles(sapply(X.ls, function(x) colQuantiles(x, probs = 0.1)), probs=.2)
range.r <- rowQuantiles(sapply(X.ls, function(x) colQuantiles(x, probs = 0.9)), probs=.8)
within <- sapply(X.ls, function(x) check(x, range.l, range.r))
select <- which(within==T)[1]
data.x <- X.ls[[select]]
y.co.0 <- data.x[1:T0,]
y.co.1 <- data.x[(T0+1),,drop=F]
data <- dgp.cond(y.co.0, y.co.1, T0, J, model, w0.u)
rownames(data$y.co.0) <- paste0("outcome.", as.character(c(1:T0)))
rownames(data$y.tr.0) <- paste0("outcome.", as.character(c(1:T0)))
rownames(data$y.co.1) <- paste0("outcome.", as.character(T0+1))
rownames(data$y.tr.1) <- paste0("outcome.", as.character(T0+1))
colnames(data$y.co.0) <- paste0("donor.", as.character(c(1:J)))
colnames(data$y.tr.0) <- paste0("treated")
colnames(data$y.co.1) <- paste0("donor.", as.character(c(1:J)))
colnames(data$y.tr.1) <- paste0("treated")
specs <- list(J = J,
K = 0,
KM = 0,
M = 1,
cointegrated.data = F,
period.pre = c(1:T0),
period.post = c(T0+1),
T0.features = c(T0),
T1.outcome = 1,
features = c("feature1"),
glob.cons = F,
out.in.features = T)
df <- list(A = data$y.tr.0, B = data$y.co.0, C = NULL, P = data$y.co.1,
Y.pre = data$y.tr.0, Y.post = data$y.tr.1, Y.donors = data$y.co.0,
specs = specs)
class(df) <- 'scpi_data'
res <- scest(df)
P
P %*% b
fit.pre
A.hat[1:T0.features[1], , drop= F]
setwd("D:\\Dropbox\\Research\\Cattaneo\\packages_old\\R\\v0.6\\data")
data <- read.csv("Germany.csv")
#data <- Germany
## Set parameters for data preparation
id.var      <- "country"                             # ID variable
time.var    <- "year"                                # Time variable
period.pre  <- seq(from = 1960, to = 1990, by = 1)   # Pre-treatment period
period.post <- (1991:1997)                           # Post-treatment period
unit.tr     <- "West Germany"                        # Treated unit (in terms of id.var)
unit.co     <- unique(data$country)[-7]              # Donors pool
outcome.var <- "gdp"                                 # Outcome variable
cov.adj     <- NULL                                  # Covariates for adjustment
features    <- NULL                                  # No features other than outcome
constant    <- T                                     # No constant term
report.missing <- F                                  # To check where missing values are
cointegrated.data <- T                               # Belief that the data are cointegrated
cov.adj <- features <- NULL
#data <- data[!(data$country == "Austria" & data$year == 1992),]
## Data preparation
df  <-   scdata(df = data, id.var = id.var, time.var = time.var, outcome.var = outcome.var,
period.pre = period.pre, period.post = period.post,
unit.tr = unit.tr, unit.co = unit.co, cov.adj = cov.adj, features = features,
constant = constant,  report.missing = T, cointegrated.data = cointegrated.data)
## Estimate Synthetic Control with a simplex-type constraint (default) and plot results
set.seed(8894)
res.est <- scest(data = df, plot = F, plot.name = "germany_est",  w.constr = list(name = "ridge", Q = 1))
P %*% b
P
data <- dgp.cond(y.co.0, y.co.1, T0, J, model, w0.u)
rownames(data$y.co.0) <- paste0("outcome.", as.character(c(1:T0)))
rownames(data$y.tr.0) <- paste0("outcome.", as.character(c(1:T0)))
rownames(data$y.co.1) <- paste0("outcome.", as.character(T0+1))
rownames(data$y.tr.1) <- as.character(T0+1)
colnames(data$y.co.0) <- paste0("donor.", as.character(c(1:J)))
colnames(data$y.tr.0) <- paste0("treated")
colnames(data$y.co.1) <- paste0("donor.", as.character(c(1:J)))
colnames(data$y.tr.1) <- paste0("treated")
specs <- list(J = J,
K = 0,
KM = 0,
M = 1,
cointegrated.data = F,
period.pre = c(1:T0),
period.post = c(T0+1),
T0.features = c(T0),
T1.outcome = 1,
features = c("feature1"),
glob.cons = F,
out.in.features = T)
df <- list(A = data$y.tr.0, B = data$y.co.0, C = NULL, P = data$y.co.1,
Y.pre = data$y.tr.0, Y.post = data$y.tr.1, Y.donors = data$y.co.0,
specs = specs)
class(df) <- 'scpi_data'
res <- scest(df)
print(res)
library(tsDyn)
library(matrixStats)
library(ggplot2)
library(optiSolve)
library(Qtools)
library(latex2exp)
library(Hmisc)
library(abind)
library(Matrix)
library(magic)
library(nloptr)
library(magic)
library(dplyr)
library(tidyr)
library(doSNOW)
library(doRNG)
library(parallel)
library(CVXR)
source("D:\\Dropbox (Personal)\\Research\\Cattaneo\\packages\\cluster_sims\\funs.R")
setwd("D:\\Dropbox\\Research\\Cattaneo\\packages\\R\\scpi\\R")
source("supporting_functions.R")
source("scest.R")
source("scpi.R")
source("scdata.R")
source("scplot.R")
source("scest_methods.R")
source("scpi_methods.R")
## Simulation Parameters
rep   <- 20      # replications
T0    <- 100     # pre-treatment period
M     <- 400     # number of simulations
J     <- c(5,10,20,30,50,100) # donors pool size
J <- 5
w0.u  <- c(0.3, 0.4, 0.3, rep(0, J-3))  # true weights
ar  <- diag(J)*0.5  # matrix of coefficients of donors pool
#######################################
### Prepare design ####################
#######################################
set.seed(8894)
X.ls <- list()
for (i in 1:rep) {
X.ls[[i]] <- dgp.x(T0, ar)
}
# pick a realization in the medium range
range.l <- rowQuantiles(sapply(X.ls, function(x) colQuantiles(x, probs = 0.1)), probs=.2)
range.r <- rowQuantiles(sapply(X.ls, function(x) colQuantiles(x, probs = 0.9)), probs=.8)
within <- sapply(X.ls, function(x) check(x, range.l, range.r))
select <- which(within==T)[1]
data.x <- X.ls[[select]]
y.co.0 <- data.x[1:T0,]
y.co.1 <- data.x[(T0+1),,drop=F]
data <- dgp.cond(y.co.0, y.co.1, T0, J, model, w0.u)
rownames(data$y.co.0) <- paste0("outcome.", as.character(c(1:T0)))
rownames(data$y.tr.0) <- paste0("outcome.", as.character(c(1:T0)))
rownames(data$y.co.1) <- paste0("outcome.", as.character(T0+1))
rownames(data$y.tr.1) <- as.character(T0+1)
colnames(data$y.co.0) <- paste0("donor.", as.character(c(1:J)))
colnames(data$y.tr.0) <- paste0("treated")
colnames(data$y.co.1) <- paste0("donor.", as.character(c(1:J)))
colnames(data$y.tr.1) <- paste0("treated")
specs <- list(J = J,
K = 0,
KM = 0,
M = 1,
cointegrated.data = F,
period.pre = c(1:T0),
period.post = c(T0+1),
T0.features = c(T0),
T1.outcome = 1,
features = c("feature1"),
glob.cons = F,
out.in.features = T)
df <- list(A = data$y.tr.0, B = data$y.co.0, C = NULL, P = data$y.co.1,
Y.pre = data$y.tr.0, Y.post = data$y.tr.1, Y.donors = data$y.co.0,
specs = specs)
class(df) <- 'scpi_data'
res <- scest(df)
print(res)
res <- scpi(df, w.constr = list(name="simplex",Q=1), cores = 1, sims = 100)
print(res)
setwd("D:\\Dropbox\\Research\\Cattaneo\\packages\\R\\scpi\\R")
source("supporting_functions.R")
source("scest.R")
source("scpi.R")
source("scdata.R")
source("scplot.R")
source("scest_methods.R")
source("scpi_methods.R")
print(res)
CI
Y.sc.post
cbind(Y.tr.post[inf.con,,drop = F], Y.sc.post)
inf.con <- rownames(Y.sc.post)
cbind(Y.tr.post[inf.con,,drop = F], Y.sc.post)
inf.con
Y.tr.post
source("D:\\Dropbox (Personal)\\Research\\Cattaneo\\packages\\cluster_sims\\funs.R")
setwd("D:\\Dropbox\\Research\\Cattaneo\\packages\\R\\scpi\\R")
source("supporting_functions.R")
source("scest.R")
source("scpi.R")
source("scdata.R")
source("scplot.R")
source("scest_methods.R")
source("scpi_methods.R")
## Simulation Parameters
rep   <- 20      # replications
T0    <- 100     # pre-treatment period
M     <- 400     # number of simulations
J     <- c(5,10,20,30,50,100) # donors pool size
J <- 5
w0.u  <- c(0.3, 0.4, 0.3, rep(0, J-3))  # true weights
ar  <- diag(J)*0.5  # matrix of coefficients of donors pool
#######################################
### Prepare design ####################
#######################################
set.seed(8894)
X.ls <- list()
for (i in 1:rep) {
X.ls[[i]] <- dgp.x(T0, ar)
}
# pick a realization in the medium range
range.l <- rowQuantiles(sapply(X.ls, function(x) colQuantiles(x, probs = 0.1)), probs=.2)
range.r <- rowQuantiles(sapply(X.ls, function(x) colQuantiles(x, probs = 0.9)), probs=.8)
within <- sapply(X.ls, function(x) check(x, range.l, range.r))
select <- which(within==T)[1]
data.x <- X.ls[[select]]
y.co.0 <- data.x[1:T0,]
y.co.1 <- data.x[(T0+1),,drop=F]
data <- dgp.cond(y.co.0, y.co.1, T0, J, model, w0.u)
rownames(data$y.co.0) <- paste0("outcome.", as.character(c(1:T0)))
rownames(data$y.tr.0) <- paste0("outcome.", as.character(c(1:T0)))
rownames(data$y.co.1) <- as.character(T0+1)
rownames(data$y.tr.1) <- as.character(T0+1)
colnames(data$y.co.0) <- paste0("donor.", as.character(c(1:J)))
colnames(data$y.tr.0) <- paste0("treated")
colnames(data$y.co.1) <- paste0("donor.", as.character(c(1:J)))
colnames(data$y.tr.1) <- paste0("treated")
specs <- list(J = J,
K = 0,
KM = 0,
M = 1,
cointegrated.data = F,
period.pre = c(1:T0),
period.post = c(T0+1),
T0.features = c(T0),
T1.outcome = 1,
features = c("feature1"),
glob.cons = F,
out.in.features = T)
df <- list(A = data$y.tr.0, B = data$y.co.0, C = NULL, P = data$y.co.1,
Y.pre = data$y.tr.0, Y.post = data$y.tr.1, Y.donors = data$y.co.0,
specs = specs)
class(df) <- 'scpi_data'
res <- scest(df)
print(res)
res <- scpi(df, w.constr = list(name="simplex",Q=1), cores = 1, sims = 100)
print(res)
scplot(res)
source("D:\\Dropbox (Personal)\\Research\\Cattaneo\\packages\\cluster_sims\\funs.R")
df <- getData(J, T0, rep)
T0    <- 1000    # pre-treatment period
df <- getData(J, T0, rep)
res <- scpi(df, w.constr = list(name="simplex",Q=1), cores = 1, sims = 100)
